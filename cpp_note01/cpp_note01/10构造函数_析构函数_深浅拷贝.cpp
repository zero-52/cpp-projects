#include<iostream>
using namespace std;

/*
构造函数：在创建对象时由编译器自动调用，为对象的成员属性赋值，且只调用一次。
析构函数：用于对象销毁前系统自动调用，执行一些清理工作，且只调用一次。

注意：构造和析构函数是必须存在的函数，若不自定义，编译器默认会提供空实现的构造函数和析构函数。

	构造函数语法：类名() {}
		构造函数，没有返回值也不写void
		函数名称与类名相同
		构造函数可以有参数，因此可以发生重载
		程序在调用对象时候会自动调用构造，无须手动调用, 而且只会调用一次（等价于python __init__函数）

	析构函数语法： ~类名() {}
		析构函数，没有返回值也不写void
		函数名称与类名相同, 在名称前加上符号 ~
		析构函数不可以有参数，因此不可以发生重载
		程序在对象销毁前会自动调用析构，无须手动调用, 而且只会调用一次（等价于python __del__函数）

	注：构造函数不止类有，结构体也可以有构造函数（使用方法和类一致）

	分类：
		按参数分为： 无参构造函数（默认构造函数） 和 有参构造函数
	​	按类型分为： 普通构造函数 和 拷贝构造函数// 类名(const 类名& p){}

	三种调用方式：
		​ 括号法
		​ 显示法
		​ 隐式转换法

	explicit 关键字：
		作用就是防止类构造函数的隐式自动转换。
		当类的声明和定义分别在两个文件中时，explicit只能写在在声明中，不能写在定义中。

		explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了
		但是, 当除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效, 此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数
		
		总结：
			explicit关键字只需用于类内的单参数构造函数前面。由于无参数的构造函数和多参数的构造函数总是显示调用，这种情况在构造函数前加explicit无意义。
			google的c++规范中提到explicit的优点是可以避免不合时宜的类型变换，缺点无。所以google约定所有单参数的构造函数都必须是显示的，只有极少数情况下拷贝构造函数可以不声明称explicit。例如作为其他类的透明包装器的类。
　　		effective c++中说：被声明为explicit的构造函数通常比其non-explicit更受欢迎。因为它们禁止编译器执行非预期（往往也不被期望）的类型转换。除非我有一个好理由允许构造函数被用于隐式类型转换，否则我会把它声明为explicit，鼓励大家遵循相同的政策。

	匿名对象：随用随亡
	//Person1();
	//Person1(10);  //匿名对象  特点：当前行执行结束后，系统会立即回收掉该匿名对象
	//Person1(p5);  //报错，不要利用 拷贝构造函数 去初始化 匿名对象

	拷贝构造函数调用时机通常有三种情况:
		1.使用一个已经创建完毕的对象来初始化一个新对象
		2.值传递的方式给函数参数传值
		3.以值方式返回局部对象


	默认情况下，c++编译器至少给一个类自动添加3个函数:
		1．默认构造函数(无参，函数体为空)
		2．默认析构函数(无参，函数体为空)
		3．默认拷贝构造函数(对属性进行值拷贝)

	构造函数创建规则如下：
		如果用户定义了有参构造函数，c++不在自动提供默认无参构造，但是会提供默认拷贝构造
		如果用户定义了拷贝构造函数，c++不会再提供其他构造函数

	
	深拷贝和浅拷贝
		浅拷贝：
			简单的赋值拷贝操作。 新旧两个对象指向同一个内容
		深拷贝：
			在堆区重新申请空间，进行拷贝操作。 新对象制作了旧对象的独立拷贝

		总结：
			如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题

			对于简单的类，类成员不含指针等，默认的拷贝构造函数（浅拷贝）一般就够用了，也没有必要采用深拷贝操作。
			但是当类持有其它资源时，例如动态分配的内存、指向其他数据的指针等，默认的拷贝构造函数就不能拷贝这些资源了，就需要定义拷贝构造函数，采用深拷贝操作，以完整地拷贝对象的所有数据。

			另外一种需要深拷贝的情况就是在创建对象时进行一些预处理工作，比如统计创建过的对象的数目、记录对象创建的时间等
		

	成员初始化列表，用来初始化属性，和构造函数类似，创建对象时自动调用，只一次
		语法：
			类名(形参)：属性1(形参1),属性2（形参2）... {}
			如	Person() :m_A(10), m_B(20), m_C(30){  }
				Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c){  }
*/

/**** 构造函数 析构函数 *****/
class Person1
{
public:
	string name;
	int age;
public:
	//构造函数：对象创建时自动调用的初始化操作
	//无参构造函数
	Person1()
	{	
		cout << "Person1 无参构造函数" << endl;  //默认构造函数
	}

	//有参构造函数
	Person1(int a)
	{
		age = a;
		cout << "Person1 有参构造函数 " << endl;
	}

	//拷贝构造函数
	Person1(const Person1& p)  //拷贝成员，所以是只读的权限const，且是引用传递
	{
		//将形参中的对象属性拷贝到当前对象身上
		age = p.age;
		cout << "Person1 拷贝构造函数" << endl;
	}

	//析构函数：对象销毁前自动调用的操作
	~Person1()
	{
		cout << "Person1 默认析构函数：" << this->age << endl;
	}
};

void test00()
{
	Person1 p1;
}


/******* 构造函数调用方法 *****/
	/*
		括号法
		​显示法
		​隐式转换法
	*/
void test01()
{
	//1. 括号法（常用）
	cout << "括号法" << endl;
	test00(); //调用默认构造和析构函数
	Person1 p1; //调用默认构造和析构函数，注意不加 ()
	// 注意：不能写成 Person1 p1(); 这是函数声明，不会被认为是创建对象，类似 int func();是函数声明
	p1.age = 3;

	Person1 p2(10);  //调用有参构造函数

	Person1 p3(p2); //调用拷贝构造函数

	cout << "p2的年龄为：" << p2.age << endl;
	cout << "p3的年龄为：" << p3.age << endl << endl;


	//2. 显示法
	cout << "显示法" << endl;
	Person1 p4;
	Person1 p5 = Person1(10);//调用有参构造  等号右侧为匿名对象，等号左侧为该对象的名字
	Person1 p6 = Person1(p5);//调用拷贝构造

	//Person1();
	//Person1(10);  //匿名对象  特点：当前行执行结束后，系统会立即回收掉该匿名对象
	//Person1(p5);  //报错，不要利用 拷贝构造函数 去初始化 匿名对象

	//3. 隐式转换法
	cout << endl << "隐式转换法" << endl;
	Person1 p7 = 10;  //调用有参构造   相当于 Person1 p7 = Person1(10);
	Person1 p8 = p7;  //调用拷贝构造
	cout << endl;
}
	

/*****************************************************************************
 *  @brief	explicit 关键字：
	作用就是防止类构造函数的隐式自动转换。
	当类的声明和定义分别在两个文件中时，explicit只能写在在声明中，不能写在定义中。

explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了
但是, 当除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效, 此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数

总结：
explicit关键字只需用于类内的单参数构造函数前面。由于无参数的构造函数和多参数的构造函数总是显示调用，这种情况在构造函数前加explicit无意义。
google的c++规范中提到explicit的优点是可以避免不合时宜的类型变换，缺点无。所以google约定所有单参数的构造函数都必须是显示的，只有极少数情况下拷贝构造函数可以不声明称explicit。例如作为其他类的透明包装器的类。
effective c++中说：被声明为explicit的构造函数通常比其non - explicit兄弟更受欢迎。因为它们禁止编译器执行非预期（往往也不被期望）的类型转换。除非我有一个好理由允许构造函数被用于隐式类型转换，否则我会把它声明为explicit，鼓励大家遵循相同的政策。

 *****************************************************************************/
class Test1
{
public:
	Test1(int num) :n(num) {}
private:
	int n;
};
class Test2
{
public:
	explicit Test2(int num) :n(num) {}
private:
	int n;
};

void explicit_test()
{
	Test1 t1 = 12;

	Test2 t2(13);
	//Test2 t3 = 14;//错误，explicit声明后不可隐式转换
}


/**** 拷贝构造函数的调用时机 */

//1.使用一个已经创建完毕的对象来初始化一个新对象
void test02()
{
	Person1 p01(20);  //有参构造
	cout << "拷贝构造被调用：使用一个已经创建完毕的对象来初始化一个新对象" << endl;
	Person1 p02(p01); //拷贝构造

	cout << "对象初始化新对象，拷贝构造函数的年龄：" << p02.age << endl;
}

//2.值传递的方式给函数参数传值
void doWork(Person1 p)
{
	p.age = 1000;
}
void test03()
{
	Person1 p03;  //默认构造
	p03.age = 20;
	cout << "拷贝构造被调用：值传递的方式给函数参数传值" << endl;
	doWork(p03);  //值传递，相当于 Person1 p = p03，拷贝构造
	cout << "值传递，拷贝构造函数的年龄为：" << p03.age << endl;
}

//3.以值方式返回局部对象
Person1 doWork2()
{
	Person1 p1;  //默认构造
	cout << "拷贝构造被调用：以值方式返回局部对象" << endl;
	return p1; 
}
void test04()
{
	Person1 p = doWork2(); //拷贝构造

}


/*** 构造函数创建规则 
	如果用户定义了有参构造函数，c++不在自动提供默认无参构造，但是会提供默认拷贝构造
	如果用户定义了拷贝构造函数，c++不会再提供其他构造函数
*/
class Test {
public:
	//无参（默认）构造函数
	Test() 
	{
		cout << "Test 无参构造函数!" << endl;
	}
	//有参构造函数
	Test(int a) 
	{
		age = a;
		cout << "Test 有参构造函数!" << endl;
	}
	//拷贝构造函数
	Test(const Test& p) 
	{
		age = p.age;
		cout << "Test 拷贝构造函数!" << endl;
	}
	//析构函数
	~Test() {
		cout << "Test 析构函数!" << endl;
	}
public:
	int age;
};

void t1()
{
	Test p1(18);
	//如果不自定义拷贝构造，编译器会自动添加默认的拷贝构造，并且做浅拷贝操作
	Test p2(p1);

	cout << "p2的年龄为： " << p2.age << endl;
}
void t2()
{
	//如果用户定义了有参构造，编译器不会提供默认构造，会提供拷贝构造
	Test p1; //此时如果用户自己没有提供默认构造，该句会出错
	Test p2(10); //用户提供的有参
	Test p3(p2); //此时如果用户没有提供拷贝构造，编译器会默认提供

	//如果用户提供拷贝构造，编译器不会提供其他构造函数
	Test p4; //此时如果用户自己没有提供默认构造，会出错
	Test p5(10); //此时如果用户自己没有提供有参，会出错
	Test p6(p5); //用户自己提供拷贝构造
}


/*** 深拷贝 和 浅拷贝

	浅拷贝：
		简单的赋值拷贝操作。  新旧两个对象指向同一个内容
	深拷贝：
		在堆区重新申请空间，进行拷贝操作。 新对象是旧对象的独立拷贝

	
	总结：
		对于简单的类，类成员不含指针等，默认的拷贝构造函数（浅拷贝）一般就够用了，也没有必要采用深拷贝操作。
		但是当类持有其它资源时，例如动态分配的内存、指向数据的指针等，默认的拷贝构造函数就不能拷贝这些资源了。
		就需要自定义拷贝构造函数，采用深拷贝操作，以完整地拷贝对象的所有数据。

		如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题

		另外一种需要深拷贝的情况就是在创建对象时进行一些预处理工作，比如统计创建过的对象的数目、记录对象创建的时间等
		
*/
class CopyTest
{
private:
	int m_age;
	int* m_height;

public:
	CopyTest() 
	{
		cout << "CopyTest 无参构造函数" << endl;
	}
	CopyTest(int age, int height)
	{
		m_age = age;
		m_height = new int(height);  //开辟堆空间
		cout << "CopyTest 有参构造函数" << endl;

	}

	//自定义拷贝构造函数，解决类中有动态资源时，浅拷贝的问题
	CopyTest(const CopyTest& cp)
	{
		cout << "CopyTest 拷贝构造函数：深拷贝" << endl;
		m_age = cp.m_age;
		//m_height = cp.m_height;  //本质浅拷贝，编译器的默认构造函数实现就是这行代码，在释放堆内存时导致出现问题
		
		//深拷贝操作，解决问题：重新在堆区创建内存
		m_height = new int(*cp.m_height);
	}

	~CopyTest()
	{
		cout << "CopyTest 析构函数，将堆区开辟的数据空间释放" << endl;
		//析构函数，将堆区开辟的数据空间释放
		if (m_height != NULL)
		{
			delete m_height;
			m_height = NULL;
		}
	}
	int getAge()
	{
		return m_age;
	}
	int getHeight()
	{
		return *m_height;
	}
};
/* 深拷贝 和 浅拷贝 */
void test05()
{
	cout << endl << "深拷贝与浅拷贝" << endl;
	CopyTest cp1(10, 160); //调用有参构造函数
	cout << "cp1的年龄为：" << cp1.getAge() << "身高为：" << cp1.getHeight() << endl;

	CopyTest cp2(cp1);  //利用编译器定义的默认拷贝构造函数时，是浅拷贝操作，若存在动态资源如堆资源，该堆区内存将被释放两次，导致运行错误
	//该情况下，浅拷贝的问题，要利用深拷贝来解决。如 CopyTest类 中拷贝构造函数
	cout << "cp2的年龄为：" << cp2.getAge() << "身高为：" << cp2.getHeight() << endl;


}


/*** 初始化列表
		语法：
			类名(形参)：属性1(形参1),属性2（形参2）... {}
			如	Person() :m_A(10), m_B(20), m_C(30){  }
				Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c){  }
				
	类对象初始化可以通过构造函数，也可以通过初始化列表
*/
class InitLs
{
public:
	int m_A;
	int m_B;
	int m_C;

	//普通函数赋初值
	/*void fuzhi(int a, int b, int c)
	{
		m_A = a; m_B = b; m_C = c;
	}*/

	//构造函数赋初值
	/*InitLs(int a, int b, int c)
	{
		m_A = a; m_B = b; m_C = c;
	}*/

	//初始化列表赋初值，自动调用，且只调用一次，这点和构造函数一样
	
	//InitLs() :m_A(11), m_B(22), m_C(33){ } //调用时，InitLs ls; 即自动调用
	InitLs(int a, int b, int c) :m_A(a), m_B(b), m_C(c)  //传参，InitLs ls(1,3,2)
	{			//冒号后 相当于 int m_A = a; ... 
		m_A = 2 * a;  //函数内部可继续更改成员属性
		cout << "InitLs 采用初始化列表" << endl;
	}
};
void test06()
{
	//InitLs ls1;
	InitLs ls1(1, 3, 2);
	cout << "m_A = " << ls1.m_A << endl;
	cout << "m_B = " << ls1.m_B << endl;
	cout << "m_C = " << ls1.m_C << endl;
}




//********** 《 main 》 *************

int main10()
{
	/* 构造函数调用方法 */
	test01();
	

	/* 拷贝构造函数的调用时机 */
	cout << endl << "拷贝构造函数的调用时机：" << endl;
	//1 使用一个已经创建完毕的对象来初始化一个新对象
	test02();

	//2 值传递的方式给函数参数传值
	test03();

	//3 以值方式返回局部对象
	test04();


	/* 构造函数创建规则 */
	t1();


	/* 深拷贝 和 浅拷贝 */
	test05();

	cout << endl <<endl;

	/* 初始化列表 
		语法：
			构造函数()：属性1(值1),属性2（值2）... {}
	*/
	test06();

	

	cout << endl;
	return 0;
}